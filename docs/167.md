# C 语言中的大 O 符号

> 原文:[https://www.javatpoint.com/big-o-notation-in-c](https://www.javatpoint.com/big-o-notation-in-c)

在 [C 编程](https://www.javatpoint.com/c-programming-language-tutorial)中的数据结构和算法中，我们已经学习了许多算法，在这些算法中，我们已经理解了算法的不同方面和目的。我们还研究了算法的复杂性以及如何分析和计算算法的复杂性。我们发现了算法的时间和空间复杂度，并得出结论，时间和空间复杂度较小的算法被评估为最佳算法。我们知道如何找到算法的最佳情况、最坏情况和平均情况。因此，为了分析所有这些复杂性并表示它们，使用了**渐近符号**的概念，在该概念下有不同的类型可用于表示复杂性。其中一种就是**大 O 符号**。

在本节中，我们将讨论大 O 符号，并简要介绍渐近符号及其类型。

### 什么是渐近符号

这些是用于算法渐近分析的数学符号。术语“渐近”描述了一种表达式，其中存在一个值趋于无穷大的变量。简而言之，它是一种描述表达式限制行为的方法。因此，使用渐近符号，我们分析了算法的复杂性及其性能。使用渐近符号，我们在分析之后确定并显示了复杂性。因此，有三种类型的渐近符号，通过它们我们可以分析算法的复杂性:

![Big O Notation in C](../Images/f9bd4251bf834139ab73de174b065415.png)

*   **大 O 符号(O):** 表示算法运行时的**上限**。大 O 符号的作用是计算算法执行所能花费的最长时间，即用于计算算法的**最坏情况时间**复杂度。
*   **ω符号(ω(n)):**它表示算法运行时间的**下限**。它用于计算算法完成其执行所需的最佳时间，即用于测量算法的**最佳情况时间**复杂度。
*   **θ符号(θ(n)):**它携带了大 O 和欧米茄符号的中间特征，因为它代表了算法的**下限和上限**。

因此，这三种渐近符号是最常用的符号，但除了这些，还有更常见的渐近符号，如线性、对数、三次等。

### 大 O 符号

大 O 符号用于表示算法运行时间的上限，从而衡量算法的最坏情况时间复杂度。它分析并计算执行输入值算法所需的时间和内存量。

**数学上，**

对于一个函数， **f(n)** 和另一个函数**g(n)**，其中两个函数都定义在某个实数(正)的无界集合上。

其中 g(n)对于 n 的所有大值都是严格正的。它可以写成:

**f(n) = O(g(n))** 其中 n 趋于无穷大 **(n → ∞)**

但是可以看到，n 到无穷大的假设没有说明，所以我们可以简单地把上面的表达式写成:

**f(n) = O(g(n))**

这里，f 和 g 是从正整数到非负实数的必要函数。

因此，大 O 渐近指的是大 n 值。

### 大 0 符号的性质

大 O 符号的某些基本属性将在下面讨论:

*   **常数乘法:**
    如果 f(n) = c.g(n)，那么 O(f(n)) = O(g(n))，其中 c 是非零常数。
*   **求和函数:**
    如果 f(n)= f<sub>1</sub>(n)+f<sub>2</sub>(n)+-+f<sub>m</sub>(n)和 f<sub>I</sub>(n)≤f<sub>I</sub>+1(n)∀I = 1，2，-，m，
    则 O(f(n)) = O(max(f1(n)，f2(n)，-，fm(n))
*   **多项式函数:**
    如果 f(n) = a0 + a1.n + a2.n2 + - + am.nm，
    则 O(f(n)) = O(nm。
*   **对数函数:**
    如果 f(n) = logan 和 g(n)=logbn，
    则 O(f(n))=O(g(n))

这里，就大 O 而言，每个日志函数都以相同的方式增加。

### 大 O 符号如何对算法进行运行时分析

为了分析算法的性能，我们用来计算和比较算法的最坏情况运行时间复杂度。被称为**恒定运行时间**的 O(1)的顺序被认为是算法的最快运行时间，其中对于不同的输入大小，算法花费的时间是相同的。然而，恒定的运行时间是算法的理想运行时间，但很少实现。这是因为算法的运行时间取决于 n 的输入大小。

**例如:**

我们知道，算法的运行时性能取决于 n 的输入大小。让我们看一些数学例子，对不同大小的 n 进行算法的运行时分析:

*   n = 20
    log(20)= 2.996；
    20 = 20；
    20 对数(20)= 59.9；
    20<sup>2</sup>= 400；
    2<sup>20</sup>= 1084576；
    20！= 2.432902+18<sup>18</sup>；
*   n = 10
    log(10)= 1；
    10 = 10；
    10 对数(10)= 10；
    10<sup>2</sup>= 100；
    2<sup>10</sup>= 1024；
    10！= 3628800;

因此，类似地，我们计算算法的运行时性能。让我们看看一些算法示例，并看看这些算法的运行时分析:

*   对于线性搜索，运行时复杂度为 O(n)。
*   对于二分搜索法来说，运行时复杂度为 0(对数 n)。
*   对于冒泡排序、选择排序、插入排序、桶排序，运行时复杂度是 O(n^c).
*   对于指数算法，如汉诺塔，运行时复杂度是 O(c^n).
*   对于堆排序、合并排序排序，运行时复杂度为 O(n log n)。

### 大 O 符号如何分析空间复杂性

确定算法的运行时间和空间复杂度至关重要。因为通过分析算法的运行时性能，我们可以知道算法的执行时间，通过分析算法的空间复杂度，我们可以知道算法占用的内存空间。因此，为了测量算法的空间复杂度，需要比较算法的最坏情况空间复杂度性能。

为了确定算法的空间复杂度，需要完成以下两个任务:

**任务 1:** 需要执行特定算法的程序。

**任务 2:** 输入 n 的大小需要知道每个项目将容纳的内存。

这两者都是首先要完成的两个重要任务，只有这样我们才能计算出一个算法的空间复杂度。

### 算法示例

下面我们提到了一些具有空间复杂性的算法示例:

*   对于线性搜索、冒泡排序、选择排序、堆排序、插入排序和二分搜索法，空间复杂度为 **O(1)** 。
*   对于基数排序，空间复杂度为 **O(n+k)** 。
*   对于快速排序排序，空间复杂度为 **O(n)** 。
*   对于合并排序，空间复杂度为 **O(log n)** 。

## C 语言中大 0 符号的例子

下面我们用 C 语言实现了选择排序算法，并计算了算法的最坏情况复杂度(大 O 表示法):

```

for(int i=0; i
```

**为了分析算法:**

*   我们可以看到 for 外循环的范围是 **i < n** ，这意味着循环的顺序是 O(n)。
*   接下来，对于内部 for 循环，也是 O(n)为 j < n。
*   对于常数 c，平均效率为 n/2，但我们忽略该常数。所以，顺序是 O(n)。
*   将内循环和外循环的阶数相乘，我们得到的运行时复杂度为 O(n^2).

你可以用 C 语言实现其他算法，分析它并以类似的方式确定复杂性。

* * *