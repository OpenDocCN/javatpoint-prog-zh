# C++双向迭代器

> 原文:[https://www.javatpoint.com/cpp-bidirectional-iterator](https://www.javatpoint.com/cpp-bidirectional-iterator)

*   双向迭代器支持前向迭代器的所有功能，还支持两个**递减运算符**(前缀和后缀)。
*   双向迭代器是用于在两个方向上访问元素的迭代器，即朝向末端的**和朝向开始的**。
*   一个**随机访问迭代器**也是一个有效的双向迭代器。
*   许多容器实现了双向迭代器，如列表、集合、多集合、映射、多映射。
*   C++提供了两个双向移动的非常数迭代器，分别是迭代器和反向迭代器。
*   C++双向迭代器具有与正向迭代器相同的特性，唯一的区别是双向迭代器也可以递减。

## 双向迭代器的性质

**假设 x 和 y 是两个迭代器**:

| 财产 | 公式 |
| 双向迭代器是默认可构造、可复制可赋值和可析构的。 | a x；
A y(x)；
y = x； |
| 可以使用等式或不等式运算符进行比较。 | x==y
x！=y |
| 它可以被取消引用，这意味着我们可以通过使用**取消引用运算符(*)** 来检索该值。 | *x |
| 可变迭代器可以作为左值取消引用。 | *x = t |
| 双向迭代器可以递增。 | x++
+++x |
| 双向迭代器也可以递减。 | x -
- x |

在上表中，**“A”为双向类型，x** 和 **y** 为迭代器类型的对象，“t”为迭代器指向的对象。

**我们来看一个简单的例子:**

```
#include <iostream>
#include<iterator>
#include<vector>
using namespace std;
int main()
{
   vector<int> v{1,2,3,4,5};                       // vector declaration
   vector<int> ::iterator itr;                        // iterator declaration
   vector<int> :: reverse_iterator ritr;         // reverse iterator declaration
   for(itr = v.begin();itr!=v.end();itr++)
   {
       cout<<*itr<<" ";
   }
   cout<<'\n';
   for(ritr = v.rbegin();ritr!= v.rend();ritr++)
   {
       cout<<*ritr<<" ";
   }
    return 0;
}

```

**输出:**

```
1 2 3 4 5
5 4 3 2 1

```

## 双向迭代器的特点

![C++ Bidirectional iterator](../Images/7e6fda42436a87282db80428939cf730.png)

*   **等式/不等式运算符**:双向迭代器可以通过使用**等式**或**不等式运算符**进行比较。只有当两个迭代器指向同一个位置时，这两个迭代器才相等。

**假设‘A’和‘B’是两个迭代器:**

```
A==B;
A!=B;

```

*   **解引用**:双向迭代器也可以解引用为**左值**和**右值**。

**假设‘A’是迭代器，‘t’是整型变量:**

```
*A = t;
  t = *A

```

*   **递增**:双向迭代器可以通过使用**运算符++()** 函数来递增。

```
A++;
++A;

```

*   **递减:双向迭代器也可以通过使用 Operator -()函数来递减。**

```
A--;
--A;

```

## 双向迭代器的局限性:

*   **关系运算符**:等式或不等式运算符可以与双向迭代器一起使用，但其他迭代器不能应用于双向迭代器。

假设‘A’和‘B’是两个迭代器:

```
A==B;           // valid
A<=B;           // invalid

```

*   **算术运算符**:算术运算符不能用于双向迭代器，因为它是按顺序访问数据的。

```
A+2;              // invalid
A+1;              // invalid

```

*   **偏移取消引用运算符**:双向迭代器不支持元素随机访问的偏移取消引用运算符或下标运算符[]。