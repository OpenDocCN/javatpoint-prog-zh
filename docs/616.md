# 红宝石线

> 原文:[https://www.javatpoint.com/ruby-multithreading](https://www.javatpoint.com/ruby-multithreading)

线程意味着轻量级子进程。这是一条独立的执行路径。在 Ruby 中，程序的不同部分可以同时运行，方法是使用多线程在程序内拆分任务，或者使用多个进程在不同程序之间拆分任务。

线程是并发编程模型的 Ruby 实现。

* * *

## Ruby 多线程

普通程序只有一个执行线程。程序中的所有语句都是按顺序执行的。

多线程程序中有多个执行线程。它使用较少的内存空间，共享相同的地址空间。多线程用于同时执行多个任务。

使用 **thread.new** 调用创建一个新线程。它不同于主线程的执行。

* * *

## 线程初始化

创建新线程 Ruby 提供了三个关键词，即**:new:::start**和**:fork。**

要启动一个新线程，将一段代码与对**线程.新、线程.启动**或**线程.分叉**的调用相关联。将创建线程。当块退出时，新线程退出。

**语法:**

```
# Original thread runs
Thread.new {
  # New thread is created.
}
# Original thread runs

```

* * *

## 线程终止

在 Ruby 中有不同的终止线程的方法。要退出给定的线程，使用类**:kill**。

**语法:**

```
thr = Thread.new { ... }
Thread.kill(thr)

```

* * *

## 红宝石线程示例

```
#!/usr/bin/ruby 
th = Thread.new do #Here we start a new thread 
  Thread.current['counter']=0 
  5.times do |i| #loop starts and increases i each time 
    Thread.current['counter']=i 
    sleep 1 
  end 
  return nil 
end 
while th['counter'].to_i < 4  do 
=begin 
th is the long running thread 
and we can access the same variable 
from inside the thread here 
=end 
  puts "Counter is #{th['counter']}" 
  sleep 0.5 
end 
puts "Long running process finished!" 

```

输出:

![Ruby Thread 1](../Images/9fd9ccd5c4a03c46c3a680c2ad79e87e.png)

* * *

## 线程生命周期

一旦创建了线程，就不需要启动它。当它获得适当的中央处理器资源时，它会自动运行。块中的最后一个表达式是线程的值。如果线程已经完全运行，value 方法返回线程值，否则 value 方法阻塞线程并在线程完成时返回。运行查询和操作线程时，线程类定义了许多方法。

通过调用线程的 Thread.join 方法，可以等待特定线程完成。

* * *

## 线程异常处理

线程可能有一些例外。如果除主线程之外的任何线程出现异常，它依赖于 abort_on_exception。默认情况下，该选项始终为假。这意味着未处理的异常将静默终止线程。这可以通过将 abort_on_exception = true 或将$DEBUG 设置为 true 来更改。

处理异常，可以使用类方法**:handle _ interrupt**。它将与线程异步处理异常。

* * *

## 线程变量和范围

线程是用块创建的。在一个块中创建的局部变量只能由该块所在的线程访问。

Ruby thread 类允许通过名称创建和访问线程局部变量。Thread 对象被视为一个散列，使用[]=写入元素，并使用[]读回它们。

* * *

## 线程调度

Ruby 支持通过在程序中使用**:停止**、**:传递**方法来调度线程。

**:stop**类方法将当前正在运行的线程置于休眠状态，并调度另一个线程的执行。一旦线程休眠，实例方法唤醒用于将线程标记为适合调度。

传递类方法试图将执行传递给另一个线程。运行的线程是否切换取决于操作系统。

线程优先级给出了一个根据线程优先级来调度线程的提示。首先调度高优先级线程。这也取决于操作系统。线程可以在采取第一个动作时增加或减少自己的优先级。

* * *

## 线程排除

Ruby 线程排除声明，当两个线程共享相同的数据，并且其中一个线程修改该数据时，我们需要确保没有线程看到彼此数据处于不一致的状态。比如银行服务器。其中一个线程操作账户中的资金转移，另一个线程为客户生成月度报告。

* * *

## 公共类方法

| 方法 | 描述 |
| 异常时中止 | 它返回全局“异常时中止”状态。默认值为真。当设置为 true 时，如果在任何线程中引发异常，所有线程都将中止。 |
| 异常时中止= | 当设置为 true 时，如果引发异常，所有线程都将中止。它会返回新的状态。 |
| 目前的 | 它返回当前正在执行的线程。 |
| 独占{block} | 它将块包装在一个中，返回块的值。 |
| 出口 | 它终止当前正在运行的线程，并安排另一个线程运行。 |
| 杀死(线程) | 它导致给定线程退出。 |
| fork([args]*){&#124;args&#124; block} | 与::new 方法基本相同。 |
| handle _ interrupt(hash){ 0...}
 | 更改异步中断时序。 |
| 目录 | 为所有可运行或已停止的线程返回一个线程对象数组。 |
| 主要的 | 返回主线程。 |
| 新建[-我...。}/ new(*args、&proc)/ new(*args){&#124;args&#124;-我...。} | 它创建一个执行给定块的新线程。 |
| 及格 | 它给线程调度器一个将执行传递给另一个线程的提示。运行中的线程可能会切换，也可能不会切换，这取决于操作系统。 |
| 挂起中断？(误差=零) | 它返回异步队列是否为空。 |
| 开始([args]*){&#124;args&#124;block} | 与::new 方法基本相同。 |
| 停止 | 它停止当前线程的执行，将其置于“睡眠”状态，并调度另一个线程的执行。 |

* * *

## 公共实例方法

| 方法 | 描述 |
| thr[符号] | 它使用字符串或符号名返回光纤局部变量的值。 |
| thr[符号] | 它使用字符串或符号名创建光纤局部变量的值。 |
| 异常时中止 | 它返回 thr 的“异常中止”状态。 |
| 异常时中止= | 设置为 true 时，如果在此 thr 中引发异常，所有线程都将中止。 |
| add_trace_func(进程) | 添加 proc 作为跟踪处理程序。 |
| 活着吗？ | 如果正在运行或正在睡眠，则返回 true。 |
| 追踪 | 它返回前方目标的当前回溯。 |
| backtrace_locations(*args) | 它返回前面目标的执行堆栈。 |
| 退出/终止/终止 | 它终止 thr 并执行另一个线程来运行。 |
| 组 | 它返回包含给定线程的线程组，或者返回零。 |
| 检查 | 它将 thr 的名称、id 和状态转储为一个字符串。 |
| 加入 | 调用线程将暂停执行并运行此 thr。 |
| 钥匙？(符号) | 如果给定字符串作为光纤局部变量存在，则返回 true。 |
| 键 | 它返回光纤局部变量名称的数组。 |
| 挂起中断？(误差=零) | 返回目标线程的异步队列是否为空。 |
| 优先 | 它返回 thr 的优先级。 |
| 优先级= | 它将 thr 的优先级设置为整数。 |
| 杀 | 它的工作原理与出口相同。 |
| 上升 | 它从给定的线程引发异常。 |
| 奔跑 | 它会唤醒 thr，使其符合调度条件。 |
| 安全级别 | 它返回对 thr 有效的安全级别。 |
| set_trace_func(进程) | 它在 thr 上建立 proc 作为处理程序。 |
| 状态 | 它返回 thr 的状态。 |
| 停下来？ | 如果他睡着了或者死了，它就会返回真。 |
| 结束的 | 它终止 thr 并安排另一个线程运行。 |
| 线程变量？(键) | 如果给定字符串作为线程局部变量存在，则返回 true。 |
| 线程变量获取(键) | 它返回已经设置的线程局部变量的值。 |
| 线程变量集(键，值) | 将具有键的线程本地设置为值。 |
| 线程变量 | 它返回一个线程局部变量数组。 |
| 价值 | 它使用 join 等待 thr 完成，并返回其值。 |
| 唤醒 | 使给定的线程符合调度条件，尽管它可能仍然阻塞输入/输出 |

* * *