# 生锈错误处理

> 原文:[https://www.javatpoint.com/rust-error-handling](https://www.javatpoint.com/rust-error-handling)

*   **错误处理**是一种机制，在这种机制中，Rust 确定错误的可能性，并在代码进行编译之前确认您采取了一些行动。
*   这种机制使程序更加健壮，因为它使您能够在为生产部署代码之前发现并处理错误。
*   Rust 编程语言不包含这些异常。

**Rust 有两种错误:**

*   不可恢复的错误:
*   可恢复错误

![Rust Error handling](../Images/f02bdd255793570485118414d7cd4d74.png)

*   **可恢复错误**:可恢复错误是向用户报告的错误，用户可以重试操作。可恢复的错误不是非常严重，完全停止该过程。用**结果< T，E >表示。可恢复错误的例子是“找不到文件”。**
    **其中 T & E 为通用参数。**
    **T** - >这是一种在成功情况下用“确定”变量返回的值。
    **E** - >这是一种错误类型，在有“Err”变量的故障情况下返回。
*   **不可恢复的错误**:当 Rust 报告一个不可恢复的错误时，那么死机！宏停止程序的执行。**例如:**“除零”就是不可恢复错误的一个例子。

## 可恢复错误与不可恢复错误

**可恢复错误**是可以以某种方式恢复的错误，而**不可恢复错误**是不能以任何方式恢复的错误。

**我们来看一个预期行为的场景:**

```

 "100".parse();

```

在上述情况下，“100”是一个字符串，因此我们无法确认上述情况是否有效。这是意料之中的行为。因此，这是一个可恢复的错误。

*   **意外行为**

![Rust Error handling](../Images/1181c95a95b98876bf3e7e0cc6e5092b.png)

**断言！**:安**断言！**用于我们想要声明某事为真时。如果它不够正确和错误，那么程序停止执行。这引起了**的恐慌！**，如果表达式在运行时没有被评估为真。

**我们来看一个简单的例子:**

```

 fn main()
{
let x : bool = false;
assert!(x==true);
}

```

**输出:**

![Rust Error handling](../Images/8b742eb2796f62955908bf76242b8bcf.png)

在上面的例子中，x 的值是假的，断言中的条件！宏是假的。因此，一个断言！唤起恐慌！在运行时。

**遥不可及！**:一个遥不可及！宏用于不可访问的代码。这个宏很有用，因为编译器不能确定不可到达的代码。不可达代码由不可达决定！在运行时。

**我们来看一个简单的例子:**

```

              enum Value
{
  Val,
}

fn get_number(_:Value)->i32
{ 
   5
}
fn find_number(val:Value)-> &'static str
{
  match get_number(val)
  {
    7 => "seven",
    8=> "eight",
	_=> unreachable!()
  }
}

fn main()
{
  println!("{}", find_number(Value::Val));
}

```

**输出:**

![Rust Error handling](../Images/370f6235cc1d9af4408b1602e1eea1d1.png)

在上面的例子中，get_number()函数返回的值是 5，它与每个模式都匹配，但与任何模式都不匹配。因此，遥不可及！宏观呼唤恐慌！宏。

* * *