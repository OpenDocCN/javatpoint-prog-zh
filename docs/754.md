# 验证日志数据类型

> 原文:[https://www.javatpoint.com/verilog-data-types](https://www.javatpoint.com/verilog-data-types)

Verilog 引入了几种新的数据类型。这些数据类型使得 RTL 描述更容易编写和理解。

数字硬件中的数据存储和传输元素使用一组 Verilog 硬件描述语言(HDL)数据类型来表示。

在 [Verilog](verilog) 中，数据类型分为***【NETS】***和 ***寄存器*** 。这些数据类型在分配和保存值的方式上有所不同，并且它们代表不同的硬件结构。

Verilog HDL 值集由四个基本值组成:

| 价值 | 描述 |
| Zero | 逻辑零或假 |
| one | 逻辑一或真 |
| X | 未知的逻辑值 |
| Z | 三态门的高阻抗 |

### 整数和实数数据类型

许多数据类型对于 [C](https://www.javatpoint.com/c-programming-language-tutorial) 程序员来说都是熟悉的。这个想法是，如果两种语言有相同的数据类型，用 C 语言建模的算法可以转换成 Verilog。

Verilog 引入了新的双态数据类型，其中每个位只有 0 或 1。在 RTL 模型中使用 ***双态*** 变量可能会使模拟器更加高效。并且它们不影响合成结果。

| 类型 | 描述 |
| 少量 | 用户定义的大小 |
| 字节 | 8 位，带符号 |
| 短缩剂 | 16 位，带符号 |
| （同 Internationalorganizations）国际组织 | 32 位，带符号 |
| 长整型 | 64 位，带符号 |

*   **双态整数类型**

与 C 语言不同，Verilog 指定了固定宽度类型的位数。

| 类型 | 描述 |
| 车辆注册号 | 用户定义的大小 |
| 逻辑 | 在各方面都与 reg 相同 |
| 整数 | 32 位，带符号 |

*   **四态整数类型**

我们更喜欢 ***逻辑*** ，因为它比 ***reg*** 好。我们可以在使用过 reg 或 ***线*** 的地方使用逻辑。

| 类型 | 描述 |
| 时间 | 64 位无符号 |
| shortreal | 就像 C 语言中的一个浮点数 |
| shortreal | 就像 C 中的双 |
| 实时 | 与真实相同 |

### 非整数数据类型

**阵列**

在 Verilog 中，我们可以定义标量和向量 ***网*** 和 ***变量*** 。我们也可以定义*内存数组*，这是一个变量类型的一维数组。

Verilog 允许网络和变量的多维数组，并取消了对内存数组使用的一些限制。

Verilog 更进一步，完善了数组的概念，允许对数组进行更多的操作。

在 Verilog 中，数组可以有*或 ***未包装*** 维度，或者两者都有。*

 ***包装尺寸**

*   保证在内存中连续布局。
*   它可以复制到任何其他包装的对象。
*   可以切片(“部分选择”)。
*   仅限于“位”类型(位、逻辑、int 等。)，其中一些(例如 int)具有固定的大小。

**未包装尺寸**

它可以以模拟器选择的任何方式排列在内存中。我们可以可靠地将一个数组复制到另一个相同类型的数组上。

对于具有不同类型的数组，我们必须使用强制转换，并且对于如何将未打包的类型强制转换为打包的类型有一些规则。

Verilog 允许对完整的解包数组和解包数组的切片进行多种操作。

为此，所涉及的阵列或切片必须具有相同的类型和形状，即相同数量和长度的未包装尺寸。

只要数组或切片元素具有相同的位数，打包的维度可能会有所不同。允许的操作有:

*   读写整个数组。
*   读写数组切片。
*   读写数组元素。
*   数组、切片和元素的相等关系

Verilog 还包括*动态数组(在模拟过程中元素的数量可能会发生变化)和 ***关联*** 数组(它们具有不连续的范围)。*

 *Verilog 包括几个查询函数和方法的数组来支持所有这些数组类型。

### 网

网络用于连接像逻辑门这样的硬件实体，因此不存储任何值。

净变量表示结构实体(如逻辑门)之间的物理连接。除了 trireg，这些变量不存储值。这些变量具有其驱动器的值，该值通过驱动电路连续变化。

一些网络数据类型是 ***、线、三、五、三、棒、三角、tri0、tri1、supply0、supply1、*** 和 ***trireg*** 。当信号为以下情况时，必须使用网络数据类型:

*   一些设备的输出驱动它。
*   它被声明为输入或输出端口。
*   在连续赋值的左边。

**1。导线**
导线代表电路中的物理导线，用于连接门或模块。在函数或块中，线的值可以被读取，但不能被赋值。

导线不存储其值，但必须由连续赋值语句驱动，或将它连接到门或模块的输出。

**2。魔杖(有线与)**
魔杖的价值取决于与之相连的所有驱动程序的逻辑与。

**3。Wor(有线或)**
wor 的值取决于与其连接的所有驱动程序的逻辑或。

**4。三态(三态)**
连接到三态的所有驱动器都必须是 z，决定三态值的驱动器除外。

**5。电源 0 和电源 1**
电源 0 和电源 1 定义连接到逻辑 0(接地)和逻辑 1(电源)的导线。

### 登记

寄存器是一个数据对象，它存储从一个过程赋值到下一个过程赋值的值。它们仅在函数和过程块中使用。

过程中的赋值语句充当触发器，改变数据存储元素的值。

Reg 是 Verilog 变量类型，不一定意味着物理寄存器。在多位寄存器中，数据存储为无符号数，对于用户可能认为是二进制补码的数字，不进行符号扩展。

有些寄存器数据类型是***【reg】***、整数、时间， ***real.reg*** 是最常用的类型。

*   **Reg** 用于描述逻辑。
*   **整数**是通用变量。它们主要用于循环-索引、参数和常数。它们将数据存储为带符号的数字，而显式声明的 reg 类型将数据存储为无符号的。如果它们包含编译时未定义的数字，它们的大小将默认为 32 位。如果它们包含常数，合成器会将它们调整到编译时所需的最小宽度。
*   **系统模块中的真实**。
*   **时间**和**实时**用于在测试台中存储模拟时间。时间是一个 64 位的量，可以与$time 系统任务结合使用来保存模拟时间。

#### 注:寄存器不必总是代表触发器，因为它也可以代表组合逻辑。

*   在模拟开始时，reg 变量被初始化为 x。任何未连接到任何对象的线变量都有 x 值。
*   声明期间可以指定寄存器或线的大小。
*   当寄存器或线路大小超过一位时，寄存器和线路被声明为矢量。

### Verilog 字符串

字符串存储在 reg 中，reg 变量的宽度必须足够大以容纳字符串。

字符串中的每个字符代表一个 [ASCII](https://www.javatpoint.com/ascii-full-form) 值，需要 1 个字节。如果变量的大小小于字符串，Verilog 会截断字符串最左边的位。如果变量的大小大于字符串，Verilog 会在字符串的左边添加零。

* * ***